# 排列熵 Permutation Entropy
排列熵(`Permutation Entropy`, PE)算法是*Bandt, Pompe(2001)*提出的一种度量时间序列复杂性的方法，它首先通过相空间重构以及子序列排序提取序列模式的概率分布，再根据概率分布计算出这段时间序列的熵值。

## 相空间重构
假设有一段长度为$n$的非线性系统的离散时间序列$\{x_i,i=1,2,\cdots,n\}$，我们希望从这段时间序列中提取信息，比如信号的复杂程度，这时候就需要对时间序列进行相空间重构。  
*Packard et al. (1980)*对于时间序列的相空间重构，提出了两种重构方法，分别是导数重构法和坐标延迟重构法，这里采用的是坐标延迟法。使用坐标延迟法对相空间重构涉及到两个参数，一个是嵌入维度(`Embedding Dimension`) $m$，它控制生成的列向量的维度；另一个是延迟时间(`Delay Time`) $\tau$，它控制子序列的采样间隔，比如当 $\tau$=1 时，即是连续取点；当 $\tau$=2 时，即是间隔1个数取值。选定好参数 $m$ 和 $\tau$ 以后，可以得到一个矩阵：
$$
\begin{bmatrix}
    x_1 & x_{1+\tau} & \cdots & x_{1+(m-1)\tau}\\
    x_2 & x_{2+\tau} & \cdots & x_{2+(m-1)\tau}\\
    \vdots & \vdots & &\vdots\\
    x_j & x_{j+1} & \cdots & x_{j+(m-1)\tau}\\
    \vdots & \vdots & & \vdots\\
    x_k & x_{k+\tau} & \cdots & x_{k+(m-1)\tau}
\end{bmatrix}
$$  
其中$k=n-(m-1)\tau; j=1, 2, \cdots, k$。

## 排列熵计算
一维序列$\{x_i\}$进行相空间重构后可以得到一个$k \times m$的矩阵，对矩阵行分块，分为$k$个行向量，第$i$行的向量$\{x_i, x_{i+\tau},\cdots,x_{i+(m-1)\tau}\}$称为$X_i,1 \le i \le k$。  
在$X_i$内部进行排序，使得：
$$
x_{i+(j_1-1)\tau} \le x_{i+(j_2-1)\tau} \le \cdots \le x_{i+(j_m-1)\tau}
$$  
由此可得到一个序列$\{j_1,j_2,\cdots,j_m\}$，$j_1,j_2,\cdots,j_m$表示已好排序的新数组内的元素原本在$X_i$内的索引且$1\le j_1,j_2,\cdots,j_m \le m$。【注：这个操作类似于numpy.argsort(arr)，将数组内的元素进行排序然后返回各个数据的索引，但是在Python里面索引范围是0~len(arr)-1】  
1~$m$，共$m$个数，可有$m!$种排列(`permutation`)，将这些排列按照字典序排序，然后编号为$\pi_1,\pi_2,\cdots,\pi_{m!}$。统计序号向量组中$\pi_1,\pi_2,\cdots,\pi_{m!}$的频数，再计算出每一个排列出现的概率$p_1,p_2,\cdots,p_{m!}$。  
最后再根据香农熵(`Shannon Entropy`)的定义计算出排列熵：
$$
H_{pe}=-\sum_{j=1}^{k}p_j\log_2(p_j)
$$
为了方便，可以将$H_{pe}(m)$进行归一化处理，即：
$$
0 \le \frac{H_{pe}}{\log_2(m!)} \le 1
$$  
$H_{pe}$的大小表示时间序列$\{x_i\}$的随机程度。$H_{pe}$的值越小，说明时间序列越规律；反之，则时间序列越接近随机。$H_{pe}$的变化反映并放大了时间序列的微小细节变化。
## 使用排列熵进行信号分析
